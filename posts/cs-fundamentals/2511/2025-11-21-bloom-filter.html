<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8">
  <title>Bloom Filter: Probabilistic Set Membership for High-Throughput Systems</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Bloom Filter는 메모리 효율적인 확률적 집합 검사 자료구조로, 디스크/네트워크 I/O를 줄여 대규모 시스템에서 성능과 비용을 절감합니다.">
  <link rel="stylesheet" href="/tech-knowledge-log/style.css?v=8">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
  <style>
    .topic-meta{color:#6b7280;margin-bottom:1.5rem;line-height:1.8}
    .topic-meta strong{color:#1a1a1a;font-weight:600}
    .topic-section{background:#f9fafb;border:1px solid #e5e7eb;padding:1.5rem;border-radius:12px;margin:1.5rem 0}
    .topic-section h2{margin-top:0;color:#1a1a1a;font-size:1.25rem;font-weight:600;margin-bottom:1rem}
    .topic-section p{margin:0.75rem 0;color:#374151;line-height:1.7}
    
    /* 코드 블록 스타일 */
    pre {
      background: #282c34;
      color: #abb2bf;
      padding: 1.5rem;
      border-radius: 8px;
      overflow-x: auto;
      margin: 1rem 0;
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      font-size: 0.9rem;
      line-height: 1.6;
    }
    
    code {
      background: #f4f4f4;
      padding: 0.2rem 0.4rem;
      border-radius: 4px;
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      font-size: 0.9em;
      color: #e06c75;
    }
    
    pre code {
      background: transparent;
      padding: 0;
      color: inherit;
      font-size: 0.9rem;
    }
  </style>
</head>
<body>
  <header>
    <div class="header-content">
      <a href="/tech-knowledge-log/index.html" class="site-title">Tech Knowledge Log</a>
      <nav>
        <a href="/tech-knowledge-log/archive.html">Archive</a>
      </nav>
    </div>
  </header>

  <main class="container">
    <article class="post-content">
      <h1>Bloom Filter: Probabilistic Set Membership for High-Throughput Systems</h1>
      <div class="topic-meta">
        <div><strong>난이도 / Difficulty:</strong> Intermediate</div>
        <div><strong>날짜 / Date:</strong> 2025-11-21</div>
      </div>

      <section class="topic-section">
        <h2>내용</h2>
        <p>Bloom Filter는 메모리 효율적인 확률적 집합 검사 자료구조로, 디스크/네트워크 I/O를 줄여 대규모 시스템에서 성능과 비용을 절감합니다.</p>
        <p>작동 원리: 고정 크기 비트 배열과 k개의 해시 함수를 사용합니다. 원소 삽입 시 k개의 해시 위치를 1로 세팅하고, 검사 시 모든 위치가 1이면 "있다(확률적)"로 판정합니다. 거짓 양성(false positive)은 가능하지만 거짓 음성(false negative)은 없습니다. 수식적으로 최적 k ≈ (m/n) ln2이고, 허용되는 오탐률 p를 주면 필요한 비트 수 m ≈ - (n ln p) / (ln2)^2로 계산합니다. 구현 팁: 두 개의 해시값으로 k개를 만들도록 Kirsch–Mitzenmacher 기법을 쓰면 해시 비용을 줄입니다.<br><br>실무 확장: 삭제를 지원하려면 Counting Bloom Filter(카운터 배열)를 사용하고, 시간에 따른 만료나 대량 삽입에는 스케일 아웃 가능한 Scalable Bloom Filter를 고려합니다. 디스크 기반 SSTable 시스템(예: Bigtable/HBase/Cassandra)은 SSTable마다 Bloom Filter를 유지해 불필요한 디스크 읽기를 회피합니다.</p>
        <h2 style="margin-top:1.5rem;">활용</h2>
        <div>실제 사용 사례:<br>- 사례: Google Bigtable (Bigtable 논문, 2006) — SSTable 레벨에서 Bloom Filter로 읽기 I/O 감소<br>  코드: Guava Java 예시 (com.google.guava:guava:31.1-jre)<br><pre><code class="language-java">import com.google.common.hash.BloomFilter;<br>import com.google.common.hash.Funnels;<br>BloomFilter&lt;CharSequence&gt; bf = BloomFilter.create(Funnels.stringFunnel(Charsets.UTF_8), 1_000_000, 0.01);<br>bf.put("user:1234");<br>boolean maybe = bf.mightContain("user:1234");</code></pre><br>  실무 패턴: false-positive를 동반하므로 2차 검증(예: 디스크 키-존재 확인)을 항상 설계. 노드 간 필터를 이진 직렬화하여 네트워크로 전송해 캐시 프루닝에 사용.<br><br>- 사례: Apache Cassandra/HBase — Memtable/ SSTable 접근 전에 Bloom Filter 체크로 디스크 I/O 절감<br>- 사례: RedisBloom 모듈(모듈 버전: redis/modules/rebloom) — BF.ADD, BF.EXISTS 명령<br>  코드:<br><pre><code class="language-bash"># RedisBloom 사용<br>BF.RESERVE bloom1 0.01 100000<br>BF.ADD bloom1 user:1234<br>BF.EXISTS bloom1 user:1234</code></pre><br><br>Best practices: 목표 false-positive p를 산정해 m,k를 계산, 해시 함수는 MurmurHash3 기반 사용, 삭제 필요 시 Counting BF, 확장 필요 시 Scalable BF 채택.</div>
      </section>

      <section class="topic-section">
        <h2>Content</h2>
        <p>A Bloom Filter is a memory-efficient probabilistic membership structure used to reduce disk/network I/O in large-scale systems by answering "maybe in set" queries quickly.</p>
        <p>How it works: A Bloom Filter uses a fixed-size bit array and k hash functions. Insertion sets k bit positions to 1; membership checks test whether all k bits are 1. It allows false positives but no false negatives. Optimal parameters follow k ≈ (m/n) ln2 and m ≈ - (n ln p) / (ln2)^2 given expected items n and false-positive rate p. Practical implementations use Kirsch–Mitzenmacher double-hashing to generate k hashes from two base hashes to lower hashing cost.<br><br>Extensions: Deletions require Counting Bloom Filters (counters per bucket). For growing workloads use Scalable Bloom Filters. In LSM-based stores (Bigtable/HBase/Cassandra), per-SSTable Bloom Filters block unnecessary disk seeks, greatly improving read throughput and lowering cost.</p>
        <h2 style="margin-top:1.5rem;">Applications</h2>
        <div>Real-world case:<br>- Case: Google Bigtable (Bigtable paper, 2006) — per-SSTable Bloom Filters to avoid disk reads<br>  Code: Guava Java example (com.google.guava:guava:31.1-jre)<br><pre><code class="language-java">import com.google.common.hash.BloomFilter;<br>import com.google.common.hash.Funnels;<br>BloomFilter&lt;CharSequence&gt; bf = BloomFilter.create(Funnels.stringFunnel(Charsets.UTF_8), 1_000_000, 0.01);<br>bf.put("user:1234");<br>boolean maybe = bf.mightContain("user:1234");</code></pre><br>  Production patterns: always plan a second-step authoritative check (disk/DB) due to false positives; serialize filters compactly for cluster-wide distribution.<br><br>- Case: Apache Cassandra / HBase — use Bloom Filters on memtable/SSTable levels to skip SSTable reads<br>- Case: RedisBloom module (RedisBloom, module repo) — commands BF.RESERVE, BF.ADD, BF.EXISTS<br>  CLI:<br><pre><code class="language-bash">BF.RESERVE bloom1 0.01 100000<br>BF.ADD bloom1 user:1234<br>BF.EXISTS bloom1 user:1234</code></pre><br><br>Best practices: compute m and k from expected n and p, use MurmurHash3-based hashes (Guava uses Murmur3_128), pick Counting/Scalable variants when deletion or growth is required.</div>
      </section>
    </article>
  </main>

  <footer>
    <p>&copy; 2025 Tech Knowledge Log. All rights reserved.</p>
  </footer>

  <script src="/tech-knowledge-log/script.js?v=8"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
</body>
</html>