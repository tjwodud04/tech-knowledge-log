<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8">
  <title>Bloom Filter — Approximate Membership in Production Systems</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Bloom Filter는 메모리 효율적 확률적 집합 검사 구조로, 대규모 시스템에서 디스크/네트워크 I/O를 줄여 성능을 개선합니다.">
  <link rel="stylesheet" href="/tech-knowledge-log/style.css?v=8">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
  <style>
    .topic-meta{color:#6b7280;margin-bottom:1.5rem;line-height:1.8}
    .topic-meta strong{color:#1a1a1a;font-weight:600}
    .topic-section{background:#f9fafb;border:1px solid #e5e7eb;padding:1.5rem;border-radius:12px;margin:1.5rem 0}
    .topic-section h2{margin-top:0;color:#1a1a1a;font-size:1.25rem;font-weight:600;margin-bottom:1rem}
    .topic-section p{margin:0.75rem 0;color:#374151;line-height:1.7}
    
    /* 코드 블록 스타일 */
    pre {
      background: #282c34;
      color: #abb2bf;
      padding: 1.5rem;
      border-radius: 8px;
      overflow-x: auto;
      margin: 1rem 0;
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      font-size: 0.9rem;
      line-height: 1.6;
    }
    
    code {
      background: #f4f4f4;
      padding: 0.2rem 0.4rem;
      border-radius: 4px;
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      font-size: 0.9em;
      color: #e06c75;
    }
    
    pre code {
      background: transparent;
      padding: 0;
      color: inherit;
      font-size: 0.9rem;
    }
  </style>
</head>
<body>
  <header>
    <div class="header-content">
      <a href="/tech-knowledge-log/index.html" class="site-title">Tech Knowledge Log</a>
      <nav>
        <a href="/tech-knowledge-log/archive.html">Archive</a>
      </nav>
    </div>
  </header>

  <main class="container">
    <article class="post-content">
      <h1>Bloom Filter — Approximate Membership in Production Systems</h1>
      <div class="topic-meta">
        <div><strong>난이도 / Difficulty:</strong> Intermediate</div>
        <div><strong>날짜 / Date:</strong> 2025-11-15</div>
      </div>

      <section class="topic-section">
        <h2>내용</h2>
        <p>Bloom Filter는 메모리 효율적 확률적 집합 검사 구조로, 대규모 시스템에서 디스크/네트워크 I/O를 줄여 성능을 개선합니다.</p>
        <p>작동 원리: k개의 해시 함수와 m비트 비트맵을 사용해 n개의 원소를 삽입/검사합니다. 삽입 시 k비트에 1을 세트하고, 조회는 모든 k비트가 1이면 '있을 가능성 있음' (False Positive 존재), 하나라도 0이면 확실히 없음. 수식으로 최적 해시 수 <code>k = (m/n) ln2</code>, 기대 오차율 <code>f ≈ (1 - e^{-kn/m})^k</code>로 튜닝합니다. 확장/삭제가 필요하면 Counting Bloom이나 Scalable Bloom(동적 확장)을 사용합니다.<br><br>생산환경 적용: 실제 시스템은 Bloom 필터를 캐시/스토리지 필터링에 씁니다. 예: HBase/Cassandra의 SSTable 레벨 필터는 디스크 조회를 피해 레이턴시를 낮추고, RedisBloom 모듈은 메모리 기반 빠른 체크를 제공합니다. 엔지니어는 예상 삽입수(<code>expectedInsertions</code>)와 목표 허용 오차(<code>falsePositiveProbability</code>)를 명시해 메모리-정확도 트레이드오프를 관리합니다.</p>
        
        <h2 style="margin-top:1.5rem;">활용</h2>
        <div>
          <p><strong>실제 사용 사례:</strong></p>
          
          <h3>사례: HBase/Hadoop 에코시스템에서 SSTable 필터링</h3>
          <p><strong>출처:</strong> HBase 2.x 코드베이스</p>
          <pre><code class="language-java">ColumnFamilyDescriptor cfd = ColumnFamilyDescriptorBuilder
  .newBuilder(Bytes.toBytes("cf"))
  .setBloomFilterType(BloomType.ROW)
  .build();</code></pre>
          <p><strong>실무 패턴:</strong> BloomType.ROW는 row key 기준 필터링으로 디스크 I/O 절감(읽기 집약적 테이블에 유리).</p>

          <h3>사례: Guava BloomFilter (많은 자바 서비스에서 사용)</h3>
          <pre><code class="language-java">BloomFilter&lt;String&gt; bf = BloomFilter.create(
  Funnels.stringFunnel(StandardCharsets.UTF_8), 1_000_000, 0.01);
bf.put("user:123");
if (!bf.mightContain("user:456")) { // skip DB
  // avoid DB hit
}</code></pre>
          <p><strong>버전:</strong> Guava 31.x 이상 권장</p>

          <h3>사례: RedisBloom 모듈로 네트워크/캐시 필터링</h3>
          <p><strong>코드</strong> (Redis module 2.2+, Redis 6+):</p>
          <pre><code class="language-bash">BF.RESERVE bf1 0.01 1000000
BF.ADD bf1 "bad:url"
BF.EXISTS bf1 "maybe:url"</code></pre>
          <p><strong>실무 패턴:</strong> 작은 FPR(1%)로 캐시 미스/디스크 조회를 크게 줄임.</p>

          <p><strong>베스트 프랙티스:</strong> 예상 항목 수를 과소 설정하지 말고(과소 설정 시 FPR 급증), 삭제 필요하면 Counting Bloom 사용, 멀티노드 환경은 필터를 직렬화하여 서비스 시작 시 로딩하거나 레이어드 필터(메모리+디스크) 적용.</p>
        </div>
      </section>

      <section class="topic-section">
        <h2>Content</h2>
        <p>A Bloom Filter is a memory‑efficient probabilistic membership structure that reduces disk/network I/O in large systems by rejecting non-members cheaply.</p>
        <p>How it works: A Bloom Filter uses k hash functions and an m-bit bitmap to insert/check n items. Insert sets k bits; lookup returns 'possibly present' if all k bits are 1 (false positives possible) and 'definitely absent' if any bit is 0. Key formulas: optimal <code>k = (m/n) ln2</code>, false positive rate <code>f ≈ (1 - e^{-kn/m})^k</code>. For deletions or dynamic growth use Counting Bloom or Scalable Bloom filters.<br><br>Systems use: Production systems apply Bloom filters as a fast pre-check before expensive operations. HBase/Cassandra place Bloom filters per SSTable to avoid unnecessary disk seeks; RedisBloom offers memory-backed filters for low-latency checks. Engineers tune <code>expectedInsertions</code> and <code>falsePositiveProbability</code> to balance RAM vs accuracy.</p>
        
        <h2 style="margin-top:1.5rem;">Applications</h2>
        <div>
          <p><strong>Real-world use case:</strong></p>
          
          <h3>Case: HBase (SSTable/HFile level filtering)</h3>
          <p><strong>Source:</strong> HBase 2.x API</p>
          <pre><code class="language-java">ColumnFamilyDescriptor cfd = ColumnFamilyDescriptorBuilder
  .newBuilder(Bytes.toBytes("cf"))
  .setBloomFilterType(BloomType.ROW)
  .build();</code></pre>
          <p><strong>Production patterns:</strong> BloomType.ROW reduces disk seeks for read-heavy workloads by filtering row-key non-matches.</p>

          <h3>Case: Guava BloomFilter used in Java services</h3>
          <p><strong>Code</strong> (Guava 31.x+):</p>
          <pre><code class="language-java">BloomFilter&lt;String&gt; bf = BloomFilter.create(
  Funnels.stringFunnel(StandardCharsets.UTF_8), 1_000_000, 0.01);
bf.put("user:123");
if (!bf.mightContain("user:456")) { /* skip DB */ }</code></pre>

          <h3>Case: RedisBloom module (Redis 6+, RedisBloom 2.2+)</h3>
          <pre><code class="language-bash">BF.RESERVE bf1 0.01 1000000
BF.ADD bf1 "bad:url"
BF.EXISTS bf1 "maybe:url"</code></pre>
          <p><strong>Production patterns:</strong> choose target FPR (e.g., 1%) and expected cardinality; persist/replicate filters or rebuild on startup. Use Counting Bloom when deletions required; use layered filters (in-memory + on-disk) to balance memory and false-positive costs.</p>

          <p><strong>Notes:</strong> Bloom filters were widely adopted in systems like Chrome Safe Browsing (URL checks) and in wide-column stores (Cassandra/HBase) to avoid I/O.</p>
        </div>
      </section>
    </article>
  </main>

  <footer>
    <p>&copy; 2025 Tech Knowledge Log. All rights reserved.</p>
  </footer>

  <script src="/tech-knowledge-log/script.js?v=8"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
</body>
</html>