<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8">
  <title>Two-Pointer Technique / 투 포인터 기법</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="두 포인터 기법은 배열/시퀀스에서 두 개의 인덱스를 사용해 선형 시간으로 문제를 푸는 패턴으로, 정렬·윈도우·머지 연산에서 메모리·속도 효율을 극대화합니다.">
  <link rel="stylesheet" href="/tech-knowledge-log/style.css?v=8">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
  <style>
    .topic-meta{color:#6b7280;margin-bottom:1.5rem;line-height:1.8}
    .topic-meta strong{color:#1a1a1a;font-weight:600}
    .topic-section{background:#f9fafb;border:1px solid #e5e7eb;padding:1.5rem;border-radius:12px;margin:1.5rem 0}
    .topic-section h2{margin-top:0;color:#1a1a1a;font-size:1.25rem;font-weight:600;margin-bottom:1rem}
    .topic-section p{margin:0.75rem 0;color:#374151;line-height:1.7}
    
    /* 코드 블록 스타일 */
    pre {
      background: #282c34;
      color: #abb2bf;
      padding: 1.5rem;
      border-radius: 8px;
      overflow-x: auto;
      margin: 1rem 0;
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      font-size: 0.9rem;
      line-height: 1.6;
    }
    
    code {
      background: #f4f4f4;
      padding: 0.2rem 0.4rem;
      border-radius: 4px;
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      font-size: 0.9em;
      color: #e06c75;
    }
    
    pre code {
      background: transparent;
      padding: 0;
      color: inherit;
      font-size: 0.9rem;
    }
  </style>
</head>
<body>
  <header>
    <div class="header-content">
      <a href="/tech-knowledge-log/index.html" class="site-title">Tech Knowledge Log</a>
      <nav>
        <a href="/tech-knowledge-log/archive.html">Archive</a>
      </nav>
    </div>
  </header>

  <main class="container">
    <article class="post-content">
      <h1>Two-Pointer Technique / 투 포인터 기법</h1>
      <div class="topic-meta">
        <div><strong>난이도 / Difficulty:</strong> Intermediate</div>
        <div><strong>날짜 / Date:</strong> 2026-01-09</div>
      </div>

      <section class="topic-section">
        <h2>내용</h2>
        <p>두 포인터 기법은 배열/시퀀스에서 두 개의 인덱스를 사용해 선형 시간으로 문제를 푸는 패턴으로, 정렬·윈도우·머지 연산에서 메모리·속도 효율을 극대화합니다.</p>
        <p>작동 원리: 하나의 배열에서 head/tail(또는 i/j) 포인터를 이동시키며 조건을 유지하거나 갱신하는 방식입니다. 슬라이딩 윈도우(연속 구간 합/최대 길이), 정렬된 입력의 병합(merge-join), 제자리(partition) 연산에서 주로 쓰이며 O(n) 시간·O(1) 추가 메모리를 기대할 수 있습니다. 실무적 이점은 메모리 로컬리티와 낮은 GC/할당비용으로 고성능 시스템(데이터베이스, 스트리밍)에 적합하다는 점입니다.<br><br>시스템 적용: 데이터베이스의 정렬 병합 조인(merge join)은 두 테이블을 정렬 기준으로 스캔하며 두 포인터로 일치하는 키를 찾습니다(예: PostgreSQL의 nodeMergejoin.c 구현). 스트리밍/윈도우 집계에서는 이벤트 버퍼의 head/tail 인덱스로 만료(eviction)를 구현해 낮은 레이턴시와 작은 상태 크기를 유지합니다(예: Apache Flink의 윈도우 구현 방향).</p>
        <h2 style="margin-top:1.5rem;">활용</h2>
        <div>실제 사용 사례:<br>- 사례: PostgreSQL merge join (프로덕션 DB 엔진)<br>  코드/명령:<br>  <pre><code class="language-sql">-- 강제 merge join 플랜(예: PostgreSQL 14+)<br>  SET enable_hashjoin = off;<br>  EXPLAIN ANALYZE SELECT * FROM a JOIN b ON a.k=b.k ORDER BY a.k, b.k;</code></pre><br>  구현 위치: PostgreSQL 소스 src/backend/executor/nodeMergejoin.c (PostgreSQL 13/14 기준)<br>  실무 패턴: 입력을 미리 정렬하거나 인덱스 스캔을 이용해 순차 접근을 보장. 메모리 제한 시 merge-join이 해시조인보다 안정적.<br><br>- 사례: ClickHouse MergeTree 파트 병합<br>  코드/명령: MergeTree 엔진은 정렬된 파트를 두 포인터로 병합하여 중복 제거/정렬 병합을 수행 (예: ClickHouse v21.8+ 소스의 MergeTree 병합 로직 참조).<br>  실무 패턴: 대용량 파티션 병합 시 sequential I/O 최적화, 메모리 버퍼 크기(tuning)로 디스크 스로틀링 제어.<br><br>- 패턴/베스트프랙티스:<br>  - 입력이 정렬되어 있으면 두 포인터로 선형 스캔을 사용<br>  - 스트리밍 윈도우는 head/tail 타임스탬프 인덱스를 사용해 O(1)로 만료<br>  - 병합 시 버퍼 크기와 I/O 블록 크기를 맞춰 캐시 효율성을 높임</div>
      </section>

      <section class="topic-section">
        <h2>Content</h2>
        <p>The two-pointer technique uses two indices (e.g., head/tail) to scan sequences efficiently; it underpins sliding windows, merge joins, and in-place partitioning in production systems.</p>
        <p>How it works: move two indices according to invariants (expand/contract window, advance shorter key in merge). Common patterns: sliding window for contiguous-subarray constraints (sum, unique-count), merge of two sorted streams (merge-join), and in-place partitioning for deduplication or pivot-based algorithms. Complexity is typically O(n) time with O(1) auxiliary space, making it ideal for low-latency, low-allocation code paths in databases and stream processors.<br><br>Systems usage: DB engines implement merge joins that scan two sorted inputs with two cursors (e.g., PostgreSQL's nodeMergejoin.c). Stream processors implement window eviction by tracking head/tail offsets or timestamps in state backends (e.g., techniques used in Apache Flink window operators) to avoid full scans or expensive sorts.</p>
        <h2 style="margin-top:1.5rem;">Applications</h2>
        <div>Real-world use case:<br>- Case: Merge join in PostgreSQL (production RDBMS)<br>  Code/commands:<br>  <pre><code class="language-sql">-- Force merge join plan (PostgreSQL 14+)<br>  SET enable_hashjoin = off;<br>  EXPLAIN ANALYZE SELECT * FROM a JOIN b ON a.k=b.k ORDER BY a.k, b.k;</code></pre><br>  Implementation: see src/backend/executor/nodeMergejoin.c in PostgreSQL source (v13/14+)<br>  Production patterns: pre-sort inputs or use index scans to guarantee sequential access; prefer merge-join when memory is constrained or inputs are already ordered.<br><br>- Case: ClickHouse MergeTree merging (OLAP engine)<br>  Code/notes: MergeTree merges sorted parts using k-way/2-way merge logic; tune merge buffer and I/O block sizes for throughput (see ClickHouse repo, v21.8+ MergeTree sources).<br>  Production patterns: sequential I/O and minimal allocations; use two-pointer style scans inside merge loops for cache efficiency.<br><br>Best practices:<br>- Ensure inputs are sorted or use streaming indexes.<br>- Keep pointer updates branch-predictable and minimize allocations.<br>- For time-window eviction, maintain head/tail timestamps to expire items in O(1).</div>
      </section>
    </article>
  </main>

  <footer>
    <p>&copy; 2025 Tech Knowledge Log. All rights reserved.</p>
  </footer>

  <script src="/tech-knowledge-log/script.js?v=8"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
</body>
</html>