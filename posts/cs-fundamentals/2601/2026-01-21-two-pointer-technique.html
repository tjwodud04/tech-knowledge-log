<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8">
  <title>Two-Pointer Technique (투-포인터 기법)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="두 개의 인덱스(포인터)를 사용해 선형 시간/상수 추가 공간으로 연속 데이터 문제를 해결하는 기법으로, 생산 시스템의 성능·메모리 최적화에 자주 사용됩니다.">
  <link rel="stylesheet" href="/tech-knowledge-log/style.css?v=8">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
  <style>
    .topic-meta{color:#6b7280;margin-bottom:1.5rem;line-height:1.8}
    .topic-meta strong{color:#1a1a1a;font-weight:600}
    .topic-section{background:#f9fafb;border:1px solid #e5e7eb;padding:1.5rem;border-radius:12px;margin:1.5rem 0}
    .topic-section h2{margin-top:0;color:#1a1a1a;font-size:1.25rem;font-weight:600;margin-bottom:1rem}
    .topic-section p{margin:0.75rem 0;color:#374151;line-height:1.7}
    
    /* 코드 블록 스타일 */
    pre {
      background: #282c34;
      color: #abb2bf;
      padding: 1.5rem;
      border-radius: 8px;
      overflow-x: auto;
      margin: 1rem 0;
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      font-size: 0.9rem;
      line-height: 1.6;
    }
    
    code {
      background: #f4f4f4;
      padding: 0.2rem 0.4rem;
      border-radius: 4px;
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      font-size: 0.9em;
      color: #e06c75;
    }
    
    pre code {
      background: transparent;
      padding: 0;
      color: inherit;
      font-size: 0.9rem;
    }
  </style>
</head>
<body>
  <header>
    <div class="header-content">
      <a href="/tech-knowledge-log/index.html" class="site-title">Tech Knowledge Log</a>
      <nav>
        <a href="/tech-knowledge-log/archive.html">Archive</a>
      </nav>
    </div>
  </header>

  <main class="container">
    <article class="post-content">
      <h1>Two-Pointer Technique (투-포인터 기법)</h1>
      <div class="topic-meta">
        <div><strong>난이도 / Difficulty:</strong> Intermediate</div>
        <div><strong>날짜 / Date:</strong> 2026-01-21</div>
      </div>

      <section class="topic-section">
        <h2>내용</h2>
        <p>두 개의 인덱스(포인터)를 사용해 선형 시간/상수 추가 공간으로 연속 데이터 문제를 해결하는 기법으로, 생산 시스템의 성능·메모리 최적화에 자주 사용됩니다.</p>
        <p>작동 원리: 배열/리스트의 좌우 혹은 두 시퀀스를 동시에 가리키는 두 포인터(left/right 또는 i/j)를 이동하면서 조건을 검사·갱신합니다. 슬라이딩 윈도우(연속 구간 합, 최대 길이 서브어레이), 정렬된 두 시퀀스 병합(merge join), 중복 제거(in-place dedupe) 등에서 O(n) 또는 O(n+m)의 시간 복잡도를 달성합니다. 구현상 포인터 증감과 경계 조건을 엄격하게 처리하면 extra memory를 최소화하고 캐시 지역성을 확보해 실제 서비스에서 응답 시간과 GC/메모리 압력을 줄입니다.<br><br>실무적 중요성: 데이터베이스의 merge join(정렬된 입력을 두 포인터로 순차 합병)이나 프론트엔드의 DOM reconciliation(React의 head/tail 비교)처럼 대용량 데이터의 반복 비교를 효율화합니다. 포인터를 앞뒤로 두는 double-ended 비교는 평균 비용을 낮추고, 키(keyed) 매칭과 결합하면 최소한의 노드 교체로 상태를 유지합니다.</p>
        <h2 style="margin-top:1.5rem;">활용</h2>
        <div>실제 사용 사례:<br>- 사례: PostgreSQL Merge Join (프로덕션 DB)<br>  출처: PostgreSQL 소스 src/backend/executor/nodeMergejoin.c (PostgreSQL 14/15)<br>  코드:<br>  <pre><code class="language-c">while (left_row &amp;&amp; right_row) {<br>    cmp = compare(left_row, right_row);<br>    if (cmp &lt;= 0) emit(left_row++);<br>    if (cmp &gt;= 0) emit(right_row++);<br>  }</code></pre><br>  실무 패턴: 정렬된 입력(인덱스 스캔 or explicit SORT)과 enable_mergejoin GUC 설정으로 큰 테이블 조인 비용을 낮춤. 적절한 인덱스/통계로 planner가 merge join을 선택하게 하기.<br><br>- 사례: React reconciliation (v16+)<br>  출처: react-reconciler (reconcileChildren) — head/tail 포인터 전략<br>  코드:<br>  <pre><code class="language-js">let i = 0, j = oldChildren.length-1, k = 0;<br>  while (i&lt;=j &amp;&amp; k&lt;=newEnd) { /* compare head/tail keys, advance pointers */ }</code></pre><br>  실무 패턴: key를 안정적으로 부여해 두-포인터 방식으로 O(n) 로 최소 DOM 변경을 유도.</div>
      </section>

      <section class="topic-section">
        <h2>Content</h2>
        <p>Use of two indices (pointers) to traverse data from both ends or across two sequences to achieve linear-time, low-extra-memory solutions; widely applied for high-performance production code.</p>
        <p>How it works: Maintain two pointers (left/right or i/j) that move based on comparisons or window conditions. Typical patterns: sliding-window (max subarray length, moving sum), in-place deduplication (compact array by overwriting), and merging two sorted sequences (merge join). The technique often yields O(n) time and O(1) extra space, improving cache locality and reducing GC/heap pressure in production systems.<br><br>Practical relevance: Database engines use two-pointer merging for merge joins to stream-scan sorted inputs; front-end frameworks (React) use head/tail pointer strategies in reconciliation to minimize DOM operations. When combined with stable keys or pre-sorted inputs, the algorithm minimizes data movement and scales to large datasets with predictable latency.</p>
        <h2 style="margin-top:1.5rem;">Applications</h2>
        <div>Real-world use case:<br>- Case: PostgreSQL Merge Join (production DB)<br>  Source: PostgreSQL source src/backend/executor/nodeMergejoin.c (PostgreSQL 14/15)<br>  Code:<br>  <pre><code class="language-c">while (left_row &amp;&amp; right_row) {<br>    cmp = compare(left_row, right_row);<br>    if (cmp &lt;= 0) emit(left_row++);<br>    if (cmp &gt;= 0) emit(right_row++);<br>  }</code></pre><br>  Production patterns: Ensure sorted inputs (index scan or explicit SORT), tune planner stats and enable_mergejoin to let planner pick merge join for large-range joins.<br><br>- Case: React reconciliation (v16+)<br>  Source: react-reconciler (reconcileChildren uses head/tail comparisons)<br>  Code:<br>  <pre><code class="language-js">let i=0, j=oldChildren.length-1, k=0;<br>  while (i&lt;=j &amp;&amp; k&lt;=newEnd) { /* compare keys at head/tail, advance pointers */ }</code></pre><br>  Production patterns: Use stable keys for children to leverage linear two-pointer diffing and minimize DOM churn in UIs.</div>
      </section>
    </article>
  </main>

  <footer>
    <p>&copy; 2025 Tech Knowledge Log. All rights reserved.</p>
  </footer>

  <script src="/tech-knowledge-log/script.js?v=8"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
</body>
</html>