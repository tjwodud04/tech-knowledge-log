<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8">
  <title>Dynamic Programming (동적 계획법)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="동적 계획법은 중복 부분문제와 최적 부분구조를 이용해 복잡한 문제를 효율적으로 푸는 기법으로, 검색·음성인식·유전체 정렬 등 실제 시스템에서 핵심 성능 병목을 해결합니다.">
  <link rel="stylesheet" href="/tech-knowledge-log/style.css?v=8">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
  <style>
    .topic-meta{color:#6b7280;margin-bottom:1.5rem;line-height:1.8}
    .topic-meta strong{color:#1a1a1a;font-weight:600}
    .topic-section{background:#f9fafb;border:1px solid #e5e7eb;padding:1.5rem;border-radius:12px;margin:1.5rem 0}
    .topic-section h2{margin-top:0;color:#1a1a1a;font-size:1.25rem;font-weight:600;margin-bottom:1rem}
    .topic-section p{margin:0.75rem 0;color:#374151;line-height:1.7}
    
    /* 코드 블록 스타일 */
    pre {
      background: #282c34;
      color: #abb2bf;
      padding: 1.5rem;
      border-radius: 8px;
      overflow-x: auto;
      margin: 1rem 0;
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      font-size: 0.9rem;
      line-height: 1.6;
    }
    
    code {
      background: #f4f4f4;
      padding: 0.2rem 0.4rem;
      border-radius: 4px;
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      font-size: 0.9em;
      color: #e06c75;
    }
    
    pre code {
      background: transparent;
      padding: 0;
      color: inherit;
      font-size: 0.9rem;
    }
  </style>
</head>
<body>
  <header>
    <div class="header-content">
      <a href="/tech-knowledge-log/index.html" class="site-title">Tech Knowledge Log</a>
      <nav>
        <a href="/tech-knowledge-log/archive.html">Archive</a>
      </nav>
    </div>
  </header>

  <main class="container">
    <article class="post-content">
      <h1>Dynamic Programming (동적 계획법)</h1>
      <div class="topic-meta">
        <div><strong>난이도 / Difficulty:</strong> Intermediate</div>
        <div><strong>날짜 / Date:</strong> 2026-01-05</div>
      </div>

      <section class="topic-section">
        <h2>내용</h2>
        <p>동적 계획법은 중복 부분문제와 최적 부분구조를 이용해 복잡한 문제를 효율적으로 푸는 기법으로, 검색·음성인식·유전체 정렬 등 실제 시스템에서 핵심 성능 병목을 해결합니다.</p>
        <p>작동 원리: 문제를 상태(state)와 전이(transition)로 정의한 뒤, 작은 상태부터 결과를 누적(탭ulation)하거나 재귀와 메모이제이션으로 중복 계산을 피합니다. 시간/공간 복잡도는 상태 수와 전이 수에 비례합니다. 실무에서는 상태 설계(차원 축소, 압축 DP), 메모리 절약(rolling array), SIMD나 GPU로의 벡터화가 중요합니다.<br><br>기술적 세부: 예컨대 편집거리(Levenshtein)는 2차원 DP 테이블을 사용해 문자열 유사도를 O(nm) 시간에 계산하고, Viterbi 알고리즘은 HMM의 최빈 경로를 로그-확률 합을 통해 O(T·N^2) 또는 전이 희소성으로 가속합니다. 생물정보학의 Smith–Waterman/Needleman–Wunsch는 로컬/글로벌 정렬을 위해 점수 전이를 사용하며 SIMD 최적화(예: SSW)로 생산 환경 처리량을 올립니다.</p>
        <h2 style="margin-top:1.5rem;">활용</h2>
        <div>실제 사용 사례:<br>- 사례: Elasticsearch / Apache Lucene의 퍼지 검색<br>  코드:<br>  <pre><code class="language-json">{"query": {"fuzzy": {"name": {"value": "nme", "fuzziness": 2}}}}</code></pre><br>  출처: Lucene LevenshteinAutomata (Lucene 8+). 실무 패턴: 인덱스 레벨 n-gram/phonetic 필터와 결합해 비용 절감.<br><br>- 사례: Kaldi 음성인식의 디코더 (Viterbi)<br>  코드(개념):<br>  <pre><code class="language-python"># viterbi (간단화)<br>  for t in range(1,T):<br>    for s in states:<br>      dp[t][s] = max(dp[t-1][p]+logA[p][s])+logB[s][obs[t]]</code></pre><br>  출처: Kaldi decoders (v5.5+). 실무 패턴: beam pruning과 lattice 생성으로 메모리/시간 제어.<br><br>- 사례: 유전체 정렬 (SSW, Biopython)<br>  코드:<br>  <pre><code class="language-python">from Bio import pairwise2<br>  pairwise2.align.localms("ACGT","ACCT",2,-1,-0.5,-0.1)</code></pre><br>  출처: SSW library, Biopython. 실무 패턴: seed-and-extend로 전체 DP 호출 최소화.</div>
      </section>

      <section class="topic-section">
        <h2>Content</h2>
        <p>Dynamic programming (DP) uses overlapping subproblems and optimal substructure to solve complex tasks efficiently; it's foundational in search, speech, bioinformatics, and ML pipelines in production.</p>
        <p>How it works: Model the problem as states and transitions, then compute answers bottom-up (tabulation) or top-down with memoization to avoid recomputation. Complexity depends on the number of states and transitions; practical systems optimize state-space, use rolling arrays to cut memory, and vectorize hot loops (SIMD/GPU).<br><br>Technical details: Levenshtein (edit distance) builds a 2D DP table in O(nm) time for fuzzy matching; Viterbi finds the most likely path in an HMM using dynamic programming over time steps and states. Smith–Waterman and Needleman–Wunsch use score matrices for local/global sequence alignment; production tools apply SIMD (SSW) or seed-and-extend heuristics to scale.<br></p>
        <h2 style="margin-top:1.5rem;">Applications</h2>
        <div>Real-world use case:<br>- Case: Elasticsearch / Apache Lucene fuzzy search<br>  Code:<br>  <pre><code class="language-json">{"query": {"fuzzy": {"name": {"value": "nme", "fuzziness": 2}}}}</code></pre><br>  Source: Lucene LevenshteinAutomata (Lucene 8+). Production patterns: combine with n-gram or phonetic index filters to reduce DP invocations.<br><br>- Case: Kaldi speech decoder (Viterbi)<br>  Code (concept):<br>  <pre><code class="language-python">for t in range(1,T):<br>    for s in states:<br>      dp[t][s] = max(dp[t-1][p] + logA[p][s] for p in prev_states) + logB[s][obs[t]]</code></pre><br>  Source: Kaldi decoder implementations (v5.5+). Production patterns: beam pruning and lattice output to control latency and memory.<br><br>- Case: Sequence alignment (Biopython / SSW)<br>  Code:<br>  <pre><code class="language-python">from Bio import pairwise2<br>  pairwise2.align.localms("ACGT","ACCT",2,-1,-0.5,-0.1)</code></pre><br>  Source: Biopython pairwise2; SSW SIMD Smith–Waterman. Production patterns: use seeding/heuristics to avoid full DP on large datasets.</div>
      </section>
    </article>
  </main>

  <footer>
    <p>&copy; 2025 Tech Knowledge Log. All rights reserved.</p>
  </footer>

  <script src="/tech-knowledge-log/script.js?v=8"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
</body>
</html>