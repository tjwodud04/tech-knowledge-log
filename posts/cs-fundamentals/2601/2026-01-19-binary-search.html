<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8">
  <title>Binary Search / 이진 탐색</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="이진 탐색은 정렬된 시퀀스에서 로그 시간에 항목을 찾는 기본 알고리즘으로, 데이터베이스 인덱스 노드, 라이브러리 API, 빌드·디버깅 도구 등 실무 시스템에서 빈번히 사용됩니다.">
  <link rel="stylesheet" href="/tech-knowledge-log/style.css?v=8">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
  <style>
    .topic-meta{color:#6b7280;margin-bottom:1.5rem;line-height:1.8}
    .topic-meta strong{color:#1a1a1a;font-weight:600}
    .topic-section{background:#f9fafb;border:1px solid #e5e7eb;padding:1.5rem;border-radius:12px;margin:1.5rem 0}
    .topic-section h2{margin-top:0;color:#1a1a1a;font-size:1.25rem;font-weight:600;margin-bottom:1rem}
    .topic-section p{margin:0.75rem 0;color:#374151;line-height:1.7}
    
    /* 코드 블록 스타일 */
    pre {
      background: #282c34;
      color: #abb2bf;
      padding: 1.5rem;
      border-radius: 8px;
      overflow-x: auto;
      margin: 1rem 0;
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      font-size: 0.9rem;
      line-height: 1.6;
    }
    
    code {
      background: #f4f4f4;
      padding: 0.2rem 0.4rem;
      border-radius: 4px;
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      font-size: 0.9em;
      color: #e06c75;
    }
    
    pre code {
      background: transparent;
      padding: 0;
      color: inherit;
      font-size: 0.9rem;
    }
  </style>
</head>
<body>
  <header>
    <div class="header-content">
      <a href="/tech-knowledge-log/index.html" class="site-title">Tech Knowledge Log</a>
      <nav>
        <a href="/tech-knowledge-log/archive.html">Archive</a>
      </nav>
    </div>
  </header>

  <main class="container">
    <article class="post-content">
      <h1>Binary Search / 이진 탐색</h1>
      <div class="topic-meta">
        <div><strong>난이도 / Difficulty:</strong> Intermediate</div>
        <div><strong>날짜 / Date:</strong> 2026-01-19</div>
      </div>

      <section class="topic-section">
        <h2>내용</h2>
        <p>이진 탐색은 정렬된 시퀀스에서 로그 시간에 항목을 찾는 기본 알고리즘으로, 데이터베이스 인덱스 노드, 라이브러리 API, 빌드·디버깅 도구 등 실무 시스템에서 빈번히 사용됩니다.</p>
        <p>작동 원리: 이진 탐색은 탐색 범위를 절반씩 줄여가며 목표값을 찾습니다. 일반적인 구현은 lo, hi 포인터를 유지하고 mid = lo + (hi - lo) / 2로 계산해 오버플로를 방지합니다. 시간복잡도는 O(log n), 메모리는 O(1)입니다. 실무에서 중요한 변형은 lower_bound/upper_bound(첫 위치/마지막 이후 위치), 오프셋 기반 검색(정렬된 블록 내 삽입 위치 탐색), 그리고 monotonic predicate에 대한 이분 탐색(조건 만족 임계값 찾기)입니다.<br><br>성능/안정성 팁: 중간 인덱스 계산에서 overflow를 피하고(특히 32/64비트 경계), 반복문 기반 구현을 선호해 스택 오버헤드를 제거하세요. CPU 관점에서는 분기 예측 실패가 비용이므로 매우 뜨거운 루프에선 분기 없는(벡터화/branchless) 접근이나 라이브러리 구현(std::lower_bound)이 더 좋습니다. 분포가 균일하거나 선형적이면 보간검색(interpolation search)이 더 빠를 수 있습니다.</p>
        <h2 style="margin-top:1.5rem;">활용</h2>
        <div>실제 사용 사례:<br>- 사례: C++ 표준 라이브러리 (libstdc++, libc++)에서의 lower_bound/upper_bound<br>  코드:<br>  <pre><code class="language-cpp">#include &lt;vector&gt;<br>  #include &lt;algorithm&gt;<br>  std::vector&lt;int&gt; a = {1,3,5,7};<br>  auto it = std::lower_bound(a.begin(), a.end(), 5); // C++11+/C++17<br>  if (it != a.end() &amp;&amp; *it == 5) { /* found */ }</code></pre><br>  사용처: Chromium(구성요소와 알고리즘 최적화 코드), LLVM, 많은 서버용 C++ 코드베이스<br><br>- 사례: Python 표준 라이브러리 bisect (CPython 3.11+)<br>  코드:<br>  <pre><code class="language-python">import bisect<br>  a = [1,3,5,7]<br>  i = bisect.bisect_left(a, 4)  # returns 2, insertion index</code></pre><br>  사용처: 애플리케이션 로직, 패키지 매니저, 데이터 파이프라인에서 경계 계산<br><br>- 사례: Git의 git bisect (git 2.x)<br>  명령:<br>  <pre><code class="language-bash">git bisect start<br>  git bisect bad &lt;bad-commit&gt;<br>  git bisect good &lt;good-commit&gt;<br>  # 자동으로 커밋 히스토리를 이진 탐색해 원인 커밋을 찾음</code></pre><br>  사용처: 대규모 레포지토리에서 회귀 원인 추적(실무 개발자/엔지니어링팀)<br><br>실무 패턴:<br>- 표준 라이브러리 함수 사용(std::lower_bound, bisect, Arrays.binarySearch)으로 경계 조건과 성능 문제를 회피<br>- 임계값 탐색엔 predicate를 모나토닉하게 설계 후 이분 탐색 적용<br>- 핫 루프에선 분기 예측 비용을 고려해 branchless 방식이나 프로파일 기반 최적화 적용</div>
      </section>

      <section class="topic-section">
        <h2>Content</h2>
        <p>Binary search finds items in sorted sequences in logarithmic time; it's foundational for index node lookups, stdlib APIs, and tooling like git-bisect in production systems.</p>
        <p>How it works: Binary search maintains lo and hi bounds and repeatedly probes mid = lo + (hi - lo) / 2 to avoid integer overflow. It halves the search range each step, giving O(log n) time and O(1) memory. Variants include lower_bound/upper_bound (first >=, first >), binary search on monotonic predicates (find threshold), and interpolation search for roughly-uniform data distributions.<br><br>Practical notes: Use iterative implementations for performance and to avoid recursion overhead. Prefer well-tested library implementations (std::lower_bound, bisect, Arrays.binarySearch) which handle edge cases. In hot code, branch mispredictions can dominate cost—consider branchless algorithms or CPU-aware optimizations. When searching inside B-tree nodes or fixed-size pages, in-cache binary search outperforms linear scan above certain node sizes.</p>
        <h2 style="margin-top:1.5rem;">Applications</h2>
        <div>Real-world use case:<br>- Case: C++ STL lower_bound (libstdc++, libc++)<br>  Code:<br>  <pre><code class="language-cpp">#include &lt;vector&gt;<br>  #include &lt;algorithm&gt;<br>  std::vector&lt;int&gt; v = {1,3,5,7};<br>  auto it = std::lower_bound(v.begin(), v.end(), 5); // C++11/C++17</code></pre><br>  Where used: Chromium, LLVM, backend services with performance-critical lookups<br><br>- Case: Python bisect (CPython 3.11+)<br>  Code:<br>  <pre><code class="language-python">import bisect<br>  idx = bisect.bisect_left([1,3,5,7], 4)</code></pre><br>  Where used: scripts, data pipelines, package installers<br><br>- Case: Git bisect (Git 2.x)<br>  Command:<br>  <pre><code class="language-bash">git bisect start<br>  git bisect bad HEAD<br>  git bisect good v1.2.3</code></pre><br>  Where used: regression localization in large repositories<br><br>Production patterns:<br>- Use library primitives to avoid edge-case bugs<br>- For monotonic predicates (e.g., SLA threshold crossing), make predicate pure and fast<br>- Consider cache behavior and branchless techniques for micro-optimized paths</div>
      </section>
    </article>
  </main>

  <footer>
    <p>&copy; 2025 Tech Knowledge Log. All rights reserved.</p>
  </footer>

  <script src="/tech-knowledge-log/script.js?v=8"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
</body>
</html>