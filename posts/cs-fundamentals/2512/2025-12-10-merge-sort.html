<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8">
  <title>Merge Sort (병합 정렬)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="병합 정렬은 분할 정복 기반의 안정 정렬로, 메모리 한계를 넘는 대용량 데이터 정렬(외부 정렬)과 안정성이 필요한 시스템에서 중요합니다.">
  <link rel="stylesheet" href="/tech-knowledge-log/style.css?v=8">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
  <style>
    .topic-meta{color:#6b7280;margin-bottom:1.5rem;line-height:1.8}
    .topic-meta strong{color:#1a1a1a;font-weight:600}
    .topic-section{background:#f9fafb;border:1px solid #e5e7eb;padding:1.5rem;border-radius:12px;margin:1.5rem 0}
    .topic-section h2{margin-top:0;color:#1a1a1a;font-size:1.25rem;font-weight:600;margin-bottom:1rem}
    .topic-section p{margin:0.75rem 0;color:#374151;line-height:1.7}
    
    /* 코드 블록 스타일 */
    pre {
      background: #282c34;
      color: #abb2bf;
      padding: 1.5rem;
      border-radius: 8px;
      overflow-x: auto;
      margin: 1rem 0;
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      font-size: 0.9rem;
      line-height: 1.6;
    }
    
    code {
      background: #f4f4f4;
      padding: 0.2rem 0.4rem;
      border-radius: 4px;
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      font-size: 0.9em;
      color: #e06c75;
    }
    
    pre code {
      background: transparent;
      padding: 0;
      color: inherit;
      font-size: 0.9rem;
    }
  </style>
</head>
<body>
  <header>
    <div class="header-content">
      <a href="/tech-knowledge-log/index.html" class="site-title">Tech Knowledge Log</a>
      <nav>
        <a href="/tech-knowledge-log/archive.html">Archive</a>
      </nav>
    </div>
  </header>

  <main class="container">
    <article class="post-content">
      <h1>Merge Sort (병합 정렬)</h1>
      <div class="topic-meta">
        <div><strong>난이도 / Difficulty:</strong> Intermediate</div>
        <div><strong>날짜 / Date:</strong> 2025-12-10</div>
      </div>

      <section class="topic-section">
        <h2>내용</h2>
        <p>병합 정렬은 분할 정복 기반의 안정 정렬로, 메모리 한계를 넘는 대용량 데이터 정렬(외부 정렬)과 안정성이 필요한 시스템에서 중요합니다.</p>
        <p>작동 원리: 배열을 반으로 재귀 분할해 각 부분을 정렬한 뒤 두 정렬된 부분을 선형 시간으로 병합합니다. 내부(메모리) 정렬 시 시간복잡도는 O(n log n)이고 안정성을 보장합니다. 외부 정렬에서는 디스크에 남는 여러 정렬된 런(run)을 k-way 병합해 I/O 횟수를 줄입니다.<br><br>실무 관점: Timsort(파이썬/자바의 객체 정렬)는 병합 정렬을 기반으로 런 탐지와 길이 기반 병합 규칙을 추가해 실무 데이터의 성능을 끌어올립니다. 대규모 시스템에서는 메모리 버퍼에 채워진 블록을 디스크에 스필(spill)하고, 이후 k-way 병합으로 결합(예: Hadoop shuffle, RocksDB/LevelDB의 LSM 컴팩션, PostgreSQL의 외부 정렬)합니다.</p>
        <h2 style="margin-top:1.5rem;">활용</h2>
        <div>실제 사용 사례:<br>- 사례: PostgreSQL(예: v13/v14)에서의 외부 정렬<br>  코드:<br>  <pre><code class="language-sql">SET work_mem = '32MB';<br>  SELECT * FROM big_table ORDER BY col;</code></pre><br>  설명: work_mem보다 정렬 중 필요 메모리가 크면 PostgreSQL은 디스크 기반 외부 병합 정렬을 수행합니다. (소스: PostgreSQL 문서)<br><br>- 사례: Python/CPython(3.8+)의 정렬 및 k-way 병합<br>  코드:<br>  <pre><code class="language-python">import heapq<br>  # k-way merge of sorted iterables<br>  merged = heapq.merge(sorted_iter1, sorted_iter2, sorted_iter3)</code></pre><br>  사용처: CPython의 list.sort는 Timsort(병합 기반)를 사용해 현실 데이터에서 좋은 안정성과 성능을 냅니다.<br><br>- 사례: Hadoop MapReduce / LSM 컴팩션 (RocksDB)<br>  설정/명령:<br>  mapreduce.task.io.sort.mb=100   # (Hadoop 3.x 기본 튜닝 포인트)<br>  설명: 맵 출력은 메모리 버퍼로 스필한 뒤 디스크에 생성된 런을 병합(외부 k-way)해 리듀서로 전달하며, LSM 계열 DB는 SSTable 병합(compaction)에 k-way 병합을 사용합니다.<br><br>실무 패턴/베스트프랙티스:<br>- work_mem / io.sort 크기 조정으로 디스크 I/O 최소화<br>- 안정성이 필요하면 병합 기반 정렬 사용(객체 정렬, DB ORDER BY)<br>- 대용량은 run 생성 + multi-way merge로 설계(병렬 I/O와 버퍼 관리 중요)<br>참고: Linux kernel의 list_sort 구현도 병합 정렬 계열 함수 사용(소스: include/linux/list_sort.c).</div>
      </section>

      <section class="topic-section">
        <h2>Content</h2>
        <p>Merge sort is a stable divide-and-conquer sorting algorithm, critical for external sorting and systems needing predictable, stable sorts in production.</p>
        <p>How it works: split the array recursively, sort subarrays, then merge two sorted halves in linear time. In-memory complexity is O(n log n) and stability is preserved. For large data that doesn't fit in RAM, external merge sort writes sorted runs to disk and performs a k-way merge to minimize I/O passes.<br><br>Practical view: Many production systems use merge-based techniques rather than pure quicksort: Timsort (used by Python and Java for object sorts) extends merge sort with run detection and adaptive merging for real data. Big-data and storage systems (Hadoop shuffle, LSM-tree compaction in LevelDB/RocksDB, and RDBMS external sorts like PostgreSQL) rely on run generation + multi-way merge to scale.</p>
        <h2 style="margin-top:1.5rem;">Applications</h2>
        <div>Real-world use case:<br>- Case: PostgreSQL (e.g., v13/v14) external sort<br>  Code:<br>  <pre><code class="language-sql">SET work_mem = '32MB';<br>  SELECT * FROM big_table ORDER BY col;</code></pre><br>  Where: If sort memory exceeds work_mem, PostgreSQL performs disk-based external merge sort (Postgres docs).<br><br>- Case: CPython (3.8+) / Java Arrays.sort for objects (TimSort)<br>  Code:<br>  <pre><code class="language-python">import heapq<br>  merged = heapq.merge(sorted_iter1, sorted_iter2, sorted_iter3)</code></pre><br>  Where: CPython uses TimSort (merge-based) for list.sort; Java's Object[] sorting uses TimSort since JDK7.<br><br>- Case: Hadoop MapReduce shuffle & LSM compaction (RocksDB)<br>  Config/example:<br>  mapreduce.task.io.sort.mb=100   # Hadoop 3.x tuning point<br>  Where: Map tasks spill sorted blocks to disk and reducers perform multi-way merges; LSM stores perform compaction by merging SSTables.<br><br>Production patterns/best practices:<br>- Tune memory (work_mem/io.sort) to reduce disk spills<br>- Use k-way merge (heap-based) for merging many runs<br>- Prefer merge-based stable sorts when stability and predictable worst-case are required<br>References: PostgreSQL docs, CPython source (listsort/Timsort), Hadoop 3.x IO sort settings, RocksDB compaction docs.</div>
      </section>
    </article>
  </main>

  <footer>
    <p>&copy; 2025 Tech Knowledge Log. All rights reserved.</p>
  </footer>

  <script src="/tech-knowledge-log/script.js?v=8"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
</body>
</html>