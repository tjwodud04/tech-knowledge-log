<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8">
  <title>Sliding Window Technique</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="슬라이딩 윈도우 기법은 연속 데이터 스트림이나 시퀀스에서 고정 크기 창을 겹치며 이동시켜 로컬 통계나 집계를 유지하는 방법으로, 스트리밍 분석·네트워크 제어·시계열 처리 등 실서비스에서 지연과 정확성 균형에 중요합니다.">
  <link rel="stylesheet" href="/tech-knowledge-log/style.css?v=8">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
  <style>
    .topic-meta{color:#6b7280;margin-bottom:1.5rem;line-height:1.8}
    .topic-meta strong{color:#1a1a1a;font-weight:600}
    .topic-section{background:#f9fafb;border:1px solid #e5e7eb;padding:1.5rem;border-radius:12px;margin:1.5rem 0}
    .topic-section h2{margin-top:0;color:#1a1a1a;font-size:1.25rem;font-weight:600;margin-bottom:1rem}
    .topic-section p{margin:0.75rem 0;color:#374151;line-height:1.7}
    
    /* 코드 블록 스타일 */
    pre {
      background: #282c34;
      color: #abb2bf;
      padding: 1.5rem;
      border-radius: 8px;
      overflow-x: auto;
      margin: 1rem 0;
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      font-size: 0.9rem;
      line-height: 1.6;
    }
    
    code {
      background: #f4f4f4;
      padding: 0.2rem 0.4rem;
      border-radius: 4px;
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      font-size: 0.9em;
      color: #e06c75;
    }
    
    pre code {
      background: transparent;
      padding: 0;
      color: inherit;
      font-size: 0.9rem;
    }
  </style>
</head>
<body>
  <header>
    <div class="header-content">
      <a href="/tech-knowledge-log/index.html" class="site-title">Tech Knowledge Log</a>
      <nav>
        <a href="/tech-knowledge-log/archive.html">Archive</a>
      </nav>
    </div>
  </header>

  <main class="container">
    <article class="post-content">
      <h1>Sliding Window Technique</h1>
      <div class="topic-meta">
        <div><strong>난이도 / Difficulty:</strong> Intermediate</div>
        <div><strong>날짜 / Date:</strong> 2025-12-22</div>
      </div>

      <section class="topic-section">
        <h2>내용</h2>
        <p>슬라이딩 윈도우 기법은 연속 데이터 스트림이나 시퀀스에서 고정 크기 창을 겹치며 이동시켜 로컬 통계나 집계를 유지하는 방법으로, 스트리밍 분석·네트워크 제어·시계열 처리 등 실서비스에서 지연과 정확성 균형에 중요합니다.</p>
        <p>작동 원리: 윈도우 크기(window size)와 이동 간격(slide/step)을 정의해 각 항목이 속한 여러 겹치는 창에 이벤트를 포함시킵니다(예: 10분 창, 1분 슬라이드). 구현 관점에서는 전체 이벤트를 재계산하지 않도록 '증분 집계'(incremental aggregation)와 상태 관리(state backend)를 사용합니다. 이벤트 시간(event-time) 기반 처리에는 워터마크(watermark)로 지연 데이터를 제어하고, 상태 TTL과 정리(cleanup)를 통해 메모리 폭주를 막습니다.<br>알고리즘적 고려: naive O(window_size) 업데이트를 피하려면 해시/카운터, 큐, 또는 요약 구조(예: Count-Min, exponential histograms)를 활용합니다. 이 기법은 네트워크: TCP의 흐름 제어(sliding window, RFC 793)에서 바이트 ACK 관리, 스트리밍: Apache Flink/Spark/Kafka Streams의 hopping/sliding windows, 연구: Datar et al., "Maintaining Stream Statistics over Sliding Windows"(2002) 등에서 핵심이다.</p>
        <h2 style="margin-top:1.5rem;">활용</h2>
        <div>사례: Apache Flink에서 사용 (Flink 1.16 문서)<br>코드:<br><pre><code class="language-java">stream.keyBy(x-&gt;x.id)<br>  .window(SlidingEventTimeWindows.of(Time.minutes(10), Time.minutes(1)))<br>  .reduce(new SumReduce());</code></pre><br>사례: Spark Structured Streaming (Spark 3.3)<br>코드:<br><pre><code class="language-python">from pyspark.sql.functions import window<br>agg = df.groupBy(window(df.timestamp, '10 minutes', '1 minute'), df.key).count()</code></pre><br>사례: Kafka Streams HoppingWindows (Kafka 3.0)<br>코드:<br><pre><code class="language-java">builder.stream("topic")<br>  .groupByKey()<br>  .windowedBy(TimeWindows.ofSizeWithNoGrace(Duration.ofMinutes(10)).advanceBy(Duration.ofMinutes(1)))<br>  .count();</code></pre><br>실무 패턴: 워터마크와 허용 지연(allowed lateness) 설정, 상태 TTL/백엔드(RocksDB) 사용, 사전 집계(aggregator)로 네트워크/IO 감소, 슬라이드가 너무 작으면 상태 과다 생성 주의. 참고: Flink docs, Spark Structured Streaming guide, Datar et al. 2002, RFC 793.</div>
      </section>

      <section class="topic-section">
        <h2>Content</h2>
        <p>The sliding-window technique computes overlapping fixed-size windows over a stream or sequence to maintain local statistics or aggregates; it's widely used in streaming analytics, TCP flow control, and time-series processing for balancing latency and accuracy.</p>
        <p>How it works: you define a window size and a slide (advance) interval so each event may belong to multiple overlapping windows (e.g., 10-minute windows advancing every 1 minute). Production systems avoid recomputing whole windows by using incremental aggregations, state backends, and eviction policies. For event-time processing, watermarks handle late arrivals and you configure allowed-lateness and state cleanup to control memory.<br>Algorithmic notes: naive updates cost O(window_size) per event; real systems use queues, per-key partial aggregates, or stream summaries (Count-Min, exponential histograms) to get sublinear updates. Sliding windows appear in TCP (byte-level sliding window, RFC 793), stream frameworks (Apache Flink/Spark/Kafka Streams), and academic work like Datar et al.'s 2002 paper on maintaining stream stats over sliding windows.</p>
        <h2 style="margin-top:1.5rem;">Applications</h2>
        <div>Case: Used in Apache Flink (Flink 1.16)<br>Code:<br><pre><code class="language-java">stream.keyBy(x-&gt;x.id)<br>  .window(SlidingEventTimeWindows.of(Time.minutes(10), Time.minutes(1)))<br>  .reduce(new SumReduce());</code></pre><br>Case: Spark Structured Streaming (Spark 3.3)<br>Code:<br><pre><code class="language-python">from pyspark.sql.functions import window<br>agg = df.groupBy(window(df.timestamp, '10 minutes', '1 minute'), df.key).count()</code></pre><br>Case: Kafka Streams Hopping/Sliding (Kafka 3.0)<br>Code:<br><pre><code class="language-java">builder.stream("topic")<br>  .groupByKey()<br>  .windowedBy(TimeWindows.ofSizeWithNoGrace(Duration.ofMinutes(10)).advanceBy(Duration.ofMinutes(1)))<br>  .count();</code></pre><br>Production patterns: use watermarks and allowed lateness, backends like RocksDB for large per-key state, pre-aggregation to reduce shuffle, tune slide vs state trade-off. Sources: Apache Flink docs, Spark Structured Streaming guide, Kafka Streams docs, Datar et al. (2002), RFC 793 (TCP).</div>
      </section>
    </article>
  </main>

  <footer>
    <p>&copy; 2025 Tech Knowledge Log. All rights reserved.</p>
  </footer>

  <script src="/tech-knowledge-log/script.js?v=8"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
</body>
</html>